# user_model.dart Documentation

**File Path:** `lenshive/lib/models/user_model.dart`

## Purpose
Defines the User data model that represents a user throughout the LensHive application, handling data serialization between the frontend and backend API.

## Key Concepts & Components

### 1. **Data Model / POJO (Plain Old Dart Object)**
```dart
class User {
  final String id;
  final String fullName;
  final String email;
  // ...
}
```
- **What it is**: A class that holds data with no business logic
- **Purpose**: Type-safe data representation
- **Why use it**: Better than `Map<String, dynamic>`, provides autocompletion and compile-time checking
- **Learning**: Models are blueprints for data structure

### 2. **Immutability**
```dart
final String id;  // Cannot be changed after creation
```
- **What it is**: Fields marked as `final` cannot be reassigned
- **Why immutable**: Prevents accidental data modification, easier debugging
- **How to update**: Use `copyWith()` method to create new instance
- **Learning**: Immutability is a functional programming principle

### 3. **JSON Serialization**
```dart
factory User.fromJson(Map<String, dynamic> json)
Map<String, dynamic> toJson()
```
- **fromJson**: Converts JSON (from API) to User object
- **toJson**: Converts User object to JSON (for API/storage)
- **Why needed**: APIs communicate in JSON format
- **Learning**: Serialization = converting between formats

### 4. **Null Safety**
```dart
final String? token;        // Can be null
final DateTime? createdAt;  // Can be null
```
- **`?`**: Marks field as nullable
- **Why some nullable**: Not all fields always have values
- **Learning**: Dart's null safety prevents null reference errors

## User Model Structure

### Fields

```dart
class User {
  final String id;              // UUID from backend
  final String fullName;        // User's full name
  final String email;           // Login email
  final String? token;          // Auth token (nullable)
  final DateTime? createdAt;    // Registration date (nullable)
}
```

### Field Details

#### id (String)
```dart
final String id;
```
- **Format**: UUID string (e.g., "550e8400-e29b-41d4-a716-446655440000")
- **Source**: Generated by Django backend
- **Purpose**: Unique identifier for user
- **Why String not int**: UUIDs are strings, more secure than sequential IDs
- **Learning**: Primary key from database

#### fullName (String)
```dart
final String fullName;
```
- **Format**: Free text (e.g., "John Doe")
- **Purpose**: Display user's name in UI
- **Validation**: Minimum 3 characters (enforced in backend)
- **Usage**: Profile screen, welcome messages

#### email (String)
```dart
final String email;
```
- **Format**: Valid email (e.g., "john@example.com")
- **Purpose**: Unique login identifier
- **Validation**: Email format checked in backend
- **Usage**: Login, profile display
- **Learning**: Used as USERNAME_FIELD in backend

#### token (String?)
```dart
final String? token;
```
- **Format**: 40-character hex string (e.g., "9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b")
- **Purpose**: Authentication token for API requests
- **Nullable**: Yes (not returned in all API responses)
- **Storage**: Saved to SharedPreferences
- **Usage**: Sent in API request headers
- **Learning**: Token-based authentication

#### createdAt (DateTime?)
```dart
final DateTime? createdAt;
```
- **Format**: ISO 8601 string from API (e.g., "2024-01-15T10:30:00Z")
- **Purpose**: Track when user registered
- **Nullable**: Yes (may not be provided)
- **Usage**: Display "Member since" information
- **Learning**: DateTime handling in Dart

## Constructor

```dart
User({
  required this.id,
  required this.fullName,
  required this.email,
  this.token,
  this.createdAt,
})
```

### Parameters
- **required**: Fields that must be provided
- **optional**: Fields that can be null (token, createdAt)
- **Learning**: Named parameters with `required` keyword

## Methods

### 1. fromJson() - Factory Constructor

```dart
factory User.fromJson(Map<String, dynamic> json) {
  return User(
    id: json['_id'] ?? json['id'] ?? '',
    fullName: json['fullName'] ?? json['full_name'] ?? '',
    email: json['email'] ?? '',
    token: json['token'],
    createdAt: json['createdAt'] != null
        ? DateTime.parse(json['createdAt'])
        : null,
  );
}
```

**Purpose**: Convert JSON from API to User object

**How it works:**
1. Receives `Map<String, dynamic>` (parsed JSON)
2. Extracts each field from map
3. Handles null values with `??` operator
4. Returns new User instance

**Field Mapping:**
```dart
// Backend can send either format:
json['_id'] or json['id']        → id
json['fullName'] or json['full_name'] → fullName
json['email']                     → email
json['token']                     → token
json['createdAt']                 → createdAt
```

**Null Safety:**
```dart
json['_id'] ?? json['id'] ?? ''
// Try _id first, then id, finally empty string
```

**DateTime Parsing:**
```dart
json['createdAt'] != null
  ? DateTime.parse(json['createdAt'])
  : null
```
- **parse()**: Converts ISO 8601 string to DateTime object
- **Null check**: Only parse if not null

**Usage Example:**
```dart
// API returns: {"id": "123", "fullName": "John", "email": "john@example.com"}
final user = User.fromJson(jsonData);
print(user.fullName);  // "John"
```

### 2. toJson() - Instance Method

```dart
Map<String, dynamic> toJson() {
  return {
    'id': id,
    'fullName': fullName,
    'email': email,
    'token': token,
    'createdAt': createdAt?.toIso8601String(),
  };
}
```

**Purpose**: Convert User object to JSON for API/storage

**How it works:**
1. Creates a map with string keys
2. Assigns each field to corresponding key
3. Returns the map

**DateTime Conversion:**
```dart
createdAt?.toIso8601String()
```
- **`?.`**: Safe navigation (only call if not null)
- **toIso8601String()**: Converts DateTime to ISO format
- **Result**: "2024-01-15T10:30:00.000Z"

**Usage Example:**
```dart
final user = User(...);
final json = user.toJson();
// json = {"id": "123", "fullName": "John", ...}

// Save to storage
await prefs.setString('user', jsonEncode(user.toJson()));
```

### 3. copyWith() - Instance Method

```dart
User copyWith({
  String? id,
  String? fullName,
  String? email,
  String? token,
  DateTime? createdAt,
}) {
  return User(
    id: id ?? this.id,
    fullName: fullName ?? this.fullName,
    email: email ?? this.email,
    token: token ?? this.token,
    createdAt: createdAt ?? this.createdAt,
  );
}
```

**Purpose**: Create a new User with some fields updated

**How it works:**
1. Takes optional parameters for each field
2. Uses provided values or keeps existing ones (`this.field`)
3. Returns new User instance

**Why needed**: Since fields are `final`, we can't modify them directly

**Usage Example:**
```dart
final user = User(id: '1', fullName: 'John', email: 'john@example.com');

// Update token only
final updatedUser = user.copyWith(token: 'new-token-123');
// Result: Same id, fullName, email but new token

// Update multiple fields
final changedUser = user.copyWith(
  fullName: 'John Doe',
  token: 'abc123',
);
```

**Learning**: This is the immutable update pattern

### 4. toString() - Override

```dart
@override
String toString() {
  return 'User(id: $id, fullName: $fullName, email: $email)';
}
```

**Purpose**: Human-readable string representation

**Usage:**
```dart
print(user);  // Output: User(id: 123, fullName: John Doe, email: john@example.com)
```

**Why useful**:
- Debugging (print statements)
- Logging
- Error messages

### 5. operator == - Equality Override

```dart
@override
bool operator ==(Object other) {
  if (identical(this, other)) return true;

  return other is User &&
      other.id == id &&
      other.fullName == fullName &&
      other.email == email &&
      other.token == token;
}
```

**Purpose**: Compare two User objects for equality

**How it works:**
1. **identical()**: Check if same object in memory (fast path)
2. **Type check**: Ensure `other` is a User
3. **Field comparison**: Compare all fields

**Usage:**
```dart
final user1 = User(id: '1', fullName: 'John', email: 'john@example.com');
final user2 = User(id: '1', fullName: 'John', email: 'john@example.com');

print(user1 == user2);  // true (same values)
print(identical(user1, user2));  // false (different objects)
```

**Learning**: Without this override, `==` would only check object reference

### 6. hashCode - Hash Override

```dart
@override
int get hashCode {
  return id.hashCode ^
      fullName.hashCode ^
      email.hashCode ^
      token.hashCode;
}
```

**Purpose**: Generate hash code for object

**Why needed**: Required when overriding `==` operator

**How it works**: XOR (`^`) combines hash codes of all fields

**Usage**: Used in Set, Map for efficient lookups

**Learning**: Objects that are equal must have same hash code

## Data Flow

### User Registration Flow
```
1. User enters data in RegistrationScreen
2. Data sent to AuthProvider.register()
3. AuthProvider calls ApiService.register()
4. API returns JSON: {"id": "...", "fullName": "...", "email": "...", "token": "..."}
5. User.fromJson() converts JSON to User object
6. User object stored in AuthState
7. User.toJson() converts to JSON for SharedPreferences
8. User data displayed in ProfileScreen
```

### User Login Flow
```
1. User enters email/password in LoginScreen
2. AuthProvider calls ApiService.login()
3. API returns JSON with user data and token
4. User.fromJson() creates User object
5. User object stored in AuthState
6. User.toJson() saves to SharedPreferences
7. App navigates to HomeScreen
```

### User Data Retrieval
```
1. App starts
2. AuthProvider checks SharedPreferences
3. JSON retrieved from storage
4. User.fromJson() recreates User object
5. User object available throughout app
```

## Integration Points

### With AuthProvider
```dart
class AuthState {
  final User? user;  // Current logged-in user
  // ...
}

// Usage
ref.watch(authProvider).user?.fullName
```

### With StorageService
```dart
// Save
await StorageService.saveUser(user);

// Internally:
final userJson = jsonEncode(user.toJson());
await prefs.setString('user', userJson);

// Retrieve
final user = await StorageService.getUser();

// Internally:
final userJson = prefs.getString('user');
return User.fromJson(jsonDecode(userJson));
```

### With ApiService
```dart
// API response
{
  "user": {
    "id": "550e8400-...",
    "fullName": "John Doe",
    "email": "john@example.com"
  },
  "token": "9944b091..."
}

// Parse
final userData = json['user'];
final user = User.fromJson(userData);
final userWithToken = user.copyWith(token: json['token']);
```

## Common Patterns

### Null Handling
```dart
// Safe access to nullable fields
final displayName = user.fullName;  // Always exists
final authToken = user.token ?? 'no-token';  // Provide default
final memberSince = user.createdAt?.year ?? DateTime.now().year;
```

### Conditional Display
```dart
// In UI
Text(user.fullName)  // Always safe
Text(user.email)     // Always safe

// For nullable fields
if (user.token != null) {
  // User is authenticated
}

if (user.createdAt != null) {
  Text('Member since ${user.createdAt!.year}')
}
```

### Updating User Data
```dart
// After profile edit
final updatedUser = currentUser.copyWith(
  fullName: newName,
  email: newEmail,
);

// Save to state
state = state.copyWith(user: updatedUser);

// Save to storage
await StorageService.saveUser(updatedUser);
```

## Best Practices

### 1. Always use copyWith() for updates
```dart
// ❌ Bad (won't work, fields are final)
user.fullName = "New Name";

// ✅ Good
final updatedUser = user.copyWith(fullName: "New Name");
```

### 2. Handle null values properly
```dart
// ❌ Bad
final user = User.fromJson(json);
print(user.token.length);  // Crashes if token is null

// ✅ Good
if (user.token != null) {
  print(user.token!.length);
}
// Or
print(user.token?.length ?? 0);
```

### 3. Use proper JSON keys
```dart
// Handle both snake_case (backend) and camelCase (frontend)
json['fullName'] ?? json['full_name']
```

### 4. Validate data
```dart
// In fromJson, provide safe defaults
id: json['id'] ?? '',  // Empty string instead of null
email: json['email'] ?? '',
```

## Testing User Model

### Unit Tests
```dart
test('User.fromJson creates correct object', () {
  final json = {
    'id': '123',
    'fullName': 'John Doe',
    'email': 'john@example.com',
  };
  
  final user = User.fromJson(json);
  
  expect(user.id, '123');
  expect(user.fullName, 'John Doe');
  expect(user.email, 'john@example.com');
});

test('User.copyWith updates fields', () {
  final user = User(id: '1', fullName: 'John', email: 'john@example.com');
  final updated = user.copyWith(fullName: 'Jane');
  
  expect(updated.fullName, 'Jane');
  expect(updated.id, '1');  // Unchanged
});

test('User equality works', () {
  final user1 = User(id: '1', fullName: 'John', email: 'john@example.com');
  final user2 = User(id: '1', fullName: 'John', email: 'john@example.com');
  
  expect(user1 == user2, true);
});
```

## Common Issues & Solutions

**Issue**: "Null check operator used on null value"
- **Cause**: Trying to access nullable field without null check
- **Solution**: Use `?.` or `??` operators

**Issue**: JSON parsing fails
- **Cause**: API returns different field names
- **Solution**: Check field names in fromJson(), add fallbacks

**Issue**: Can't update user data
- **Cause**: Fields are final
- **Solution**: Use copyWith() method

**Issue**: User not persisting between sessions
- **Cause**: Not saving to SharedPreferences
- **Solution**: Call StorageService.saveUser() after changes

## Future Enhancements
- Add profile picture URL field
- Add phone number field
- Add user preferences object
- Add email verification status
- Add user role/permissions
- Add address information
- Add social media links
- Implement Equatable package for cleaner equality

## Related Files
- **auth_provider.dart**: Uses User in state
- **storage_service.dart**: Persists User data
- **api_service.dart**: Fetches User from API
- **profile_screen.dart**: Displays User information
- **Backend models.py**: Django User model (data source)

## Summary

The User model is essential for:
- ✅ Type-safe user data representation
- ✅ API response parsing
- ✅ Local data storage
- ✅ State management
- ✅ UI data display

It bridges the gap between backend JSON responses and frontend Dart objects, providing a clean, immutable way to work with user data throughout the application.

